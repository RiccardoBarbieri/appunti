\chapter{Riconoscitori LR}

\subsubsection{Parsing LR vs Parsing LL}
Costruendo l'albero top-down, la debolezza dell'analisi LL si traduce in:
\begin{itemize}
    \item deve poter identificare la produzione giusta usando soltanto i \textit{primi k simboli della parte destra}
    \item LL(1) è l'unico caso interessante
    \item LL(2) è utile in casi particolari
\end{itemize}

L'analisi LR invece, costruisce l'albero \textbf{bottom-up}:
\begin{itemize}
    \item parte dalle foglie, aspettando di avere abbastanza informazione per decidere come interpretarle
    \item meno naturale ma superiore dal punto di vista teorico
    \item ogni grammatica LL(k) è anche LR(k)
\end{itemize}

Tuttavia l'analisi LR è complessa da progettare e già il caso LR(1) spesso ingestibile per le grammatiche dei tipici linguaggi.

Sono state sviluppate \textit{tecniche semplificate}:
\begin{itemize}
    \item \textbf{SLR}: Simple LR
    \item \textbf{LALR}: Look-Ahead LR
\end{itemize}

Si utilizzano comunque sempre strumenti \textit{automatici}.

\begin{figure}[H]
    \caption{Gerarchia LR}
    \centering
    \includegraphics[width=0.7\textwidth]{/home/riccardoob/appunti/linguaggi/images/47.png}
\end{figure}

\subsubsection{Tecniche LR}
L'analisi LR procede BOTTOM UP, parte dalla frase e cerca di \textbf{riduarla} allo scopo S, ogni passo deve decidere se:
\begin{itemize}
    \item proseguire la lettura da input $\rightarrow$ \textbf{SHIFT}
    \item costruire un pezzo di albero $\rightarrow$ \textbf{REDUCE}
\end{itemize}

L'ultima REDUCE conclude l'albero con successo, accetta la frase nella fase di \textbf{ACCEPT}.

Per questo ha sempre bisogno di \textit{informazioni di contesto}.

\section{Architettura}
Il parser LR richiede un componenente, detto \textbf{ORACOLO}, che in base al contesto corrente, comunich se effettuare SHIFT o REDUCE al parser.

Un parser LR è quindi composto da:
\begin{itemize}
    \item un \textbf{oracolo}, che comunica se fare SHIFT o REDUCE
    \item uno \textbf{stack}, in cui conservare lo stato corrente di input e albero
    \item un \textbf{controller} che governa i primi due
\end{itemize}

\subsubsection{Informazione di contesto}
L'oracolo sfrutta opportune \textit{informazioni di contesto} per decidere se effettuare la lettura di un nuovo input o un passo di riduzione.

Questo componenente è un \textit{riconoscitore di contesti}, e solo se riconosce un appropriato \textit{contesto di riduzione}, ordina l'azione REDUCE appropriata per costruire senza ambiguità un certo pezzo di albero.

\section{Caso L(0)}

Nell'analisi LR conviene studiare per prima LR(0), un sottoinsieme di LR nel quale è possibile scegliere la mossa da fare \textit{senza dover guardare il prossimo simbolo di input}.

In LR questo non significa non avere informazioni in assoluto, si precludono quelle future ma si ritengono informazioni sul contesto passato.

\subsection{Analisi LR(0)}
Passi:
\begin{itemize}
    \item calcolare il \textit{contesto} LR(0) di ciascuna produzione
    \item identificare \textbf{collisioni} in contesti di produzioni diverse
    \begin{itemize}
        \item \textbf{collisione}: stringa appartenente a un contesto è un \textbf{prefisso proprio} di una stringa in un altro contesto
        \item \textbf{prefisso proprio}: una stringa è prefisso di un'altra se ciò che segue è un terminale (non metasimbolo)
    \end{itemize}
    \item se non ci sono collisioni, si possono usare i contesti LR(0) per guidare l'analisi
\end{itemize}

Se sono presenti collisioni, i contesti LR(0) non sono sufficienti, è necessario testare con LR(1).
\subsubsection{Esempio 1}
Grammatica LR(0):
\setlist{nosep}
\begin{multicols}{2}
    \begin{itemize}
        \item \texttt{S} $\rightarrow$ \texttt{a A b}
        \item \texttt{S} $\rightarrow$ \texttt{a a B b a}
        \item \texttt{A} $\rightarrow$ \texttt{A a}
        \item \texttt{A} $\rightarrow$ \texttt{b}
        \item \texttt{B} $\rightarrow$ $\varepsilon$
    \end{itemize}
    \columnbreak
    \begin{itemize}
        \item[] contesto LR(0): \texttt{\{aAb\}}
        \item[] contesto LR(0): \texttt{\{aaBba\}}
        \item[] contesto LR(0): \texttt{\{aAa\}}
        \item[] contesto LR(0): \texttt{\{ab\}}
        \item[] contesto LR(0): \texttt{\{aa\}}
    \end{itemize}
\end{multicols}
\setlist{}

Da notare che non esiste collisione tra i contesti \texttt{aaBba} e \texttt{aa}, perché la stringa \texttt{aa}, pur essendo un prefisso di \texttt{aaBba} non è \textit{prefisso proprio} di quest'ultima (\texttt{B} è un non terminale).

La frase \texttt{abab} è analizzata come segue:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{/home/riccardoob/appunti/linguaggi/images/48.png}
\end{figure}

Per ovviare a un possibile caso critico, conviene assumere che esista una produzione di \textbf{top-level} \texttt{Z} $\rightarrow$ \texttt{S}, dove \texttt{Z} è il nuovo scopo.

\subsubsection{Esempio 2}

\setlist{nosep}
\begin{multicols}{2}
    \begin{itemize}
        \item \texttt{S} $\rightarrow$ \texttt{a A b}
        \item \texttt{S} $\rightarrow$ \texttt{a a B b a}
        \item \texttt{A} $\rightarrow$ \texttt{A a}
        \item \texttt{A} $\rightarrow$ \texttt{b}
        \item \texttt{B} $\rightarrow$ $\varepsilon$
    \end{itemize}
    \columnbreak
    \begin{itemize}
        \item[] contesto LR(0): \texttt{\{aAb\}}
        \item[] contesto LR(0): \texttt{\{aaBba\}}
        \item[] contesto LR(0): \texttt{\{aAa\}}
        \item[] contesto LR(0): \texttt{\{ab\}}
        \item[] contesto LR(0): \texttt{\{aa\}}
    \end{itemize}
\end{multicols}
\setlist{}

La frase aaba è analizzata come segue:
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{/home/riccardoob/appunti/linguaggi/images/49.png}
\end{figure}

L'emulatore richiede che la grammatica sia estesa con la regola top-level \texttt{Z} $\rightarrow$ \texttt{S}.

\subsubsection{Caso critico}
Perché il calcolo dei contesti può dare una informazione fuorviante se lo scopo è riuscato nella parte destra di qualche produzione?

Si consideri l'esempio:

\setlist{nosep}
\begin{multicols}{2}
    \begin{itemize}
        \item \texttt{S} $\rightarrow$ \texttt{S a}
        \item \texttt{S} $\rightarrow$ \texttt{a}
    \end{itemize}
    \columnbreak
    \begin{itemize}
        \item[] contesto LR(0): \texttt{\{Sa\}}
        \item[] contesto LR(0): \texttt{\{a\}}
    \end{itemize}
\end{multicols}
\setlist{}

Apparentemente i contesti sono diversi, tuttavia, dato che \texttt{S} può comparire in forme di frase intermedie, la "riduzione a \texttt{S}" non sempre denota il termine di una frase.

Aggiungere la regola top-level \texttt{Z} $\rightarrow$ \texttt{S} risolve l'ambiguità.

Supponendo di dover riconoscere la frase \texttt{aaa}:
\begin{itemize}
    \item senza la top-level, nella prima mossa si riduce \texttt{a} in \texttt{S}, ma poi non è chiaro se terminare o meno:
    \begin{itemize}
        \item se non ci sono altre \texttt{a}, si è già ridotto a \texttt{S}
        \item se la stringa continua con altre \texttt{a}, si applicano altre riduzione da S\texttt{Sa} ad \texttt{S}
        \item occorre tuttavia guardare avanti di un simbolo $\rightarrow$ no LR(0)
    \end{itemize}
    \item riformulando con lo scopo \texttt{Z}
    \setlist{nosep}
    \begin{multicols}{2}
        \begin{itemize}
            \item \texttt{Z} $\rightarrow$ \texttt{S}
            \item \texttt{S} $\rightarrow$ \texttt{S a}
            \item \texttt{S} $\rightarrow$ \texttt{a}
        \end{itemize}
        \columnbreak
        \begin{itemize}
            \item[] contesto LR(0): \texttt{\{S\}}
            \item[] contesto LR(0): \texttt{\{Sa\}}
            \item[] contesto LR(0): \texttt{\{a\}}
        \end{itemize}
    \end{multicols}
    \setlist{}
    \begin{itemize}
        \item si nota che i primi due contesti collidono
    \end{itemize}
\end{itemize}

\subsection{Contesti LR(0)}
Il calcolo dei contesti LR(0) si basa sul fatto che essi sono definiti da una \textit{opportuna grammatica}.
\begin{mdframed}[topline=false,bottomline=false,rightline=false]
La grammatica che definisce i contesti LR(0) è sempre \textbf{regolare} (a sinistra).
\end{mdframed}

Ciò denota che il \textit{riconoscimento del contesto corrente}, svolto dall'oracolo, si può ottenere con un \textit{automa a stati finiti}. 

\subsubsection{Definizione}
\begin{mdframed}[topline=false,bottomline=false,rightline=false]
Il contesto LR(0) di una produzione \texttt{A} $\rightarrow$ $\alpha$\\
$\text{LR(0) ctx(\text{A}} \rightarrow \alpha) = \{\gamma | \gamma = \beta\alpha, \text{Z}\Rightarrow \beta\text{Aw} \Rightarrow \beta \alpha \text{w}, \text{w} \in \text{VT*}\}$
\end{mdframed}

Tradotto:
\begin{mdframed}[topline=false,bottomline=false,rightline=false]
Il contesto LR(0) della produzione \texttt{A} $\rightarrow$ $\alpha$ è l'insieme di tutti i \textbf{prefissi} ($\beta\alpha$) di una forma di frase che usi la produzione \texttt{A} $\rightarrow$ $\alpha$ all'ultimo passo ($\beta\alpha\text{w} \Rightarrow \beta\alpha\text{w}$) di una derivazione canonica destra.
\end{mdframed}
Conseguenza:
\begin{mdframed}[topline=false,bottomline=false,rightline=false]
Tutte le stringhe del contesto LR(0) della produzione \texttt{A} $\rightarrow$ $\alpha$ hanno la forma $\alpha\beta$ e \textit{differiscono solo per il prefisso} $\beta$.
\end{mdframed}

\subsubsection{Calcolo}
Dato che le stringhe del contesto LR(0) differiscono solo per il prefisso $\beta$, che dipende da \texttt{A}, si può esprimere il contesto come concatenazione tra insieme dei $\beta$ e il suffisso $\alpha$.

L'insieme dei $\beta$ si chiama \textbf{contesto sinistro} di \texttt{A}.

Formalmente:
\begin{mdframed}[topline=false,bottomline=false,rightline=false]
Il contesto sinistro di un non terminale \texttt{A}:
\begin{equation*}
    \text{leftctx(A)} = \{\beta | \text{Z} \Rightarrow \beta\text{Aw}, \text{w} \in \text{VT*}\}
\end{equation*}
da cui il contesto LR(0) della produzione \texttt{A} $\rightarrow$ $\alpha$
\begin{equation*}
    \text{LR(0) ctx(A}\rightarrow\alpha) = \text{leftctx(A)} \cdot \{\alpha\}
\end{equation*}
\end{mdframed}

\subsubsection{Calcolo dei contesti sinistri}
Determinare leftctx(\texttt{A}), comporta trovare tutti i modi in cui può apparire il metasimbolo \texttt{A} in una forma di frase.

Poiché lo scopo \texttt{Z} per definizione non compare mai nella parte destra di alcuna produzione, leftxctx(\texttt{Z}) = $\{ \varepsilon \}$.










































































